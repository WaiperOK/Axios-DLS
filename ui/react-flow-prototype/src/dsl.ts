import { Edge, Node } from "reactflow";
import { AxionNodeData, NodeKind } from "./types";

const SECTION_ORDER: NodeKind[] = [
  "imports",
  "asset_group",
  "scan",
  "script",
  "report",
];

export function exportToDsl(
  nodes: Node<AxionNodeData>[],
  edges: Edge[],
): string {
  const nodesById = new Map(nodes.map((node) => [node.id, node]));
  const blocks: string[] = [];

  SECTION_ORDER.forEach((kind) => {
    if (kind === "imports") {
      const importNodes = nodes.filter((node) => node.data.kind === "import");
      if (importNodes.length > 0) {
        const sorted = [...importNodes].sort((a, b) =>
          a.data.label.localeCompare(b.data.label),
        );
        sorted.forEach((node) => {
          const path = (node.data.config.path || "").trim();
          if (path) {
            blocks.push(`import "${path}"`);
          }
        });
      }
      return;
    }

    nodes
      .filter((node) => node.data.kind === kind)
      .forEach((node) => {
        switch (kind) {
          case "asset_group":
            blocks.push(renderAssetGroup(node));
            break;
          case "scan":
            blocks.push(renderScan(node, edges, nodesById));
            break;
          case "script":
            blocks.push(renderScript(node, edges, nodesById));
            break;
          case "report":
            blocks.push(renderReport(node, edges, nodesById));
            break;
        }
      });
  });

  const header = "# Generated by the React Flow prototype";
  return [header, ...blocks].filter(Boolean).join("\n\n");
}

function renderAssetGroup(node: Node<AxionNodeData>): string {
  const entries = Object.entries(node.data.config).filter(
    ([, value]) => value.trim().length > 0,
  );
  const body =
    entries.length === 0
      ? ""
      : entries
          .map(([key, value]) => `  ${key} "${value.trim()}"`)
          .join("\n");

  if (!body) {
    return `asset_group ${node.data.label} {}`;
  }

  return `asset_group ${node.data.label} {\n${body}\n}`;
}

function renderScan(
  node: Node<AxionNodeData>,
  edges: Edge[],
  map: Map<string, Node<AxionNodeData>>,
): string {
  const tool = node.data.config.tool?.trim() || "nmap";
  const header = `scan ${node.data.label} using ${tool}`;

  const inferredTarget = findUpstreamLabel(node.id, "asset_group", edges, map);
  const target =
    node.data.config.target?.trim() || inferredTarget || "127.0.0.1";
  const flags = node.data.config.flags?.trim();

  const lines = [`  target "${target}"`];
  if (flags && flags.length > 0) {
    lines.push(`  flags "${flags}"`);
  }

  let block = `${header} {\n${lines.join("\n")}\n}`;
  const output = node.data.config.output?.trim();
  if (output && output.length > 0) {
    block = `${block} -> ${output}`;
  }

  return block;
}

function renderReport(
  node: Node<AxionNodeData>,
  edges: Edge[],
  map: Map<string, Node<AxionNodeData>>,
): string {
  const includesFromConfig = (node.data.config.includes || "")
    .split(",")
    .map((value) => value.trim())
    .filter(Boolean);

  const inferred = findUpstreamLabels(node.id, edges, map).map(
    (incoming) => incoming.data.label,
  );

  const includes = includesFromConfig.length > 0 ? includesFromConfig : inferred;

  if (includes.length === 0) {
    return `report ${node.data.label} {}`;
  }

  const lines = includes.map((item) => `  include ${item}`);
  return `report ${node.data.label} {\n${lines.join("\n")}\n}`;
}

function renderScript(
  node: Node<AxionNodeData>,
  edges: Edge[],
  map: Map<string, Node<AxionNodeData>>,
): string {
  const run = node.data.config.run?.trim() || "echo \"hello\"";
  const args = node.data.config.args?.trim();
  const lines = [`  run "${run}"`];

  if (args && args.length > 0) {
    lines.push(`  args "${args}"`);
  }

  const inferredOutput = findDownstreamLabel(node.id, "report", edges, map);
  const output = node.data.config.output?.trim() || inferredOutput;

  let block = `script ${node.data.label} {\n${lines.join("\n")}\n}`;
  if (output && output.length > 0) {
    block = `${block} -> ${output}`;
  }

  return block;
}

function findUpstreamLabel(
  nodeId: string,
  kind: NodeKind,
  edges: Edge[],
  map: Map<string, Node<AxionNodeData>>,
): string | undefined {
  return findUpstreamLabels(nodeId, edges, map)
    .filter((node) => node.data.kind === kind)
    .map((node) => node.data.label)
    .shift();
}

function findUpstreamLabels(
  nodeId: string,
  edges: Edge[],
  map: Map<string, Node<AxionNodeData>>,
): Node<AxionNodeData>[] {
  return edges
    .filter((edge) => edge.target === nodeId)
    .map((edge) => map.get(edge.source))
    .filter((maybeNode): maybeNode is Node<AxionNodeData> => Boolean(maybeNode));
}

function findDownstreamLabel(
  nodeId: string,
  kind: NodeKind,
  edges: Edge[],
  map: Map<string, Node<AxionNodeData>>,
): string | undefined {
  return edges
    .filter((edge) => edge.source === nodeId)
    .map((edge) => map.get(edge.target))
    .filter((maybeNode): maybeNode is Node<AxionNodeData> => Boolean(maybeNode))
    .filter((node) => node.data.kind === kind)
    .map((node) => node.data.label)
    .shift();
}
